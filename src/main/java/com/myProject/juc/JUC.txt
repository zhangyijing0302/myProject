1.什么是JUC？
    Java.util.concurrent包
Java.util.concurrent.Callable
Java.util.concurrent.Lock

2.线程和进程？
    1.进程：一个程序，一个进程往往包含多个线程，且至少包含一个线程。
    Java默认有几个线程，2个，main和GC
    2.线程：
    JAVA中开启线程的三种方式，Thread、Runnable、Callable
    JAVA真的能开启线程吗？JAVA中启动线程是通过 private native void start0();调用的底层的C++，所以JAVA无法直接操作硬件

3.并发、并行
并发，多线程操作同一个资源，多个线程在同一个时间间隔发生，一台处理器同时处理多个任务
并行，多个线程同时运行，多个处理器同时处理多个任务
并发编程的本质：充分利用CPU的资源

4.线程有几个状态  6个 Thread.State枚举类
    // 新建 NEW,
    // 运行 RUNNABLE,
    // 阻塞 BLOCKED,
    // 等待，死等 WAITING,
    // 超时等待 TIMED_WAITING,
    // 终止 TERMINATED;

5.wait\sleep的区别
    1.java.lang.Object.wait() java.lang.Thread.sleep(long)
    2.wait会释放锁，sleep会抱着锁睡觉
    3.适用范围，wait只能在同步代码块中用，sleep可以任何地方睡
    4.都需要捕获线程中断异常
    5.wait需要被唤醒、sleep自己可以醒

6.Lock锁
    传统的synchronized，排队
    java.util.concurrent.locks.Lock接口，有三个实现类
        1.java.util.concurrent.locks.ReentrantLock.ReentrantLock(); 常用的可重入锁
        2.ReentrantReadWriteLock.ReadLock 读锁
        3.ReentrantReadWriteLock.WriteLock 写锁
    // 可重入锁构造方法，默认是非公平锁，可以指定boolean值
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    公平锁：先来后到
    非公平锁：可能发生插队

7.synchronized和Lock区别
    1.synchronized 内置的JAVA关键字、Lock是一个JAVA类
    2.synchronized 无法判断获取锁的状态，Lock可以判断是否获取到的锁
    3.synchronized 会自动释放锁，而lock必须要手动释放锁，如果不释放的话就形成死锁
    4.synchronized 线程1获得锁后，线程2会一直等待；而lock就不一定会一直等待 boolean b = lock.tryLock();
    5.synchronized 可重入锁，不可中断的，非公平锁；Lock 可重入锁，可中断的，公平不公平自己设置；
    6.synchronized 适合锁少量的代码同步问题，Lock适合锁大量的代码

8.生产者，消费者问题
    1.synchronized版本，通过wait notify实现
    2.juc版本  lock


8.锁是什么，如何判断锁的是谁
    无非两种 new 或者 static静态加载的
    new 是具体的对象 锁对象锁的是对象的调用者，new多个对象就相当于有多把锁互不相干
    static 锁的是类模板，类模板全局唯一

9.Callable 创建线程的第三种方式
    1.可以有返回值
    2.可以抛出异常
    3.启动方法不同，call()
    使用方式，通过适配器模式，
        1 Thread(Runnable) ->
        2 new FutureTask(Callable) implements RunnableFuture implements Runnable and Future ->
        3 Thread(FutureTask)
    Callable运行有缓存，能抛出异常且有返回值，但是如需要返回值的话调用get()方法可能需要等待，等待Callable线程执行完毕

10.常用的三个辅助类
    1.CountDownLatch 计数器 - 1
    2.CyclicBarrier  计数器 + 1
    3.Semaphore 信号量 许可证

11.读写锁
    interface ReadWriteLock维护了一对关联的locks，一个只用于读Lock readLock();，一个只用于写Lock writeLock();
    readLock可以由多个线程读，但是writeLock是独立的。
    ReadWriteLock lock =  new ReentrantReadWriteLock();
     lock.writeLock()
     lock.readLock()
    独占锁就是写锁，写的时候只能有一个线程去写
    共享锁就是读锁，读的时候可以由多个线程去读
    同一个锁下，读完才能写，写完才能读，写的时候其他线程不能写

    读锁有什么用？为什么读要加锁？
    任何锁表面上是互斥，但本质是都是为了避免原子性问题（如果程序没有原子性问题，那只用volatile来避免可见性和有序性问题就可以了，效率更高），
    读锁自然也是为了避免原子性问题，比如一个long型参数的写操作并不是原子性的，如果允许同时读和写，那读到的数很可能是就是写操作的中间状态，比如刚写完前32位的中间状态。
    long型数都如此，而实际上一般读的都是复杂的对象，那中间状态的情况就更多了。

12.阻塞队列
    阻塞 写入的时候 如果队列已经满了，就必须进入阻塞等待 读取的时候 如果队列的时候必须阻塞等待生产
    队列 队列的特性FIFO 先进先出
    interface BlockingQueue<E> extends Queue<E> extends Collection<E>
    已知实现类
    BlockingQueue array = new ArrayBlockingQueue();
    BlockingQueue licked = new LinkedBlockingQueue();
    BlockingQueue sync = new SynchronousQueue();

    什么情况下需要调用阻塞队列？

    四组API
    1.抛出异常  blockingQueue.add("a") blockingQueue.remove()
    2.不抛出异常，有返回值
    3.阻塞等待
    4.超时等待

    添加操作
    移除操作
    判断队列的首

    同步队列 SynchronousQueue 没有容量的概念
    必须put输入进去一个元素，必须等take取出之后才能放下一个元素

13.线程池
    1.池化技术
    程序本质上是利用系统的资源，引入池的概念的目的是为了优化资源的使用。
    常见的有线程池、常量池、数据库连接池、内存池。。。
    池化技术：池化的目的是为了减少创建、销毁所消耗的资源

    2,线程池的好处
    降低资源的消耗
    提高响应的速度
    方便管理 线程复用、控制最大并发数、管理线程

    3.线程池
    三个方法
        1.submit(Callable<T> task)、
        2.execute(Runnable command)、
        3.submit(Runnable task)
    七个参数
        1.corePoolSize 核心线程大小
        2.maximumPoolSize 最大核心线程池大小
        3.keepAliveTime 保持时间（超过这个时间没有人调用就会释放）
        4.unit 时间单位
        5.workQueue 阻塞队列
        6.threadFactory 线程工厂 创建线程
        7.handler拒绝策略
    四种拒绝策略
        1.AbortPolicy 默认拒绝策略 不处理 抛出异常
        2.CallerRunsPolicy  由调用线程处理
        3.DiscardPolicy 队列满了之后不会抛出异常, 但将丢弃被拒绝的任务
        4.DiscardOldestPolicy 队列满了之后尝试丢掉最早的线程，也可能最早的线程没有执行结束

    最大核心线程池大小如何设置？
    1.CPU 密集型 几核的CPU 就是几，可以保持CPU的运行效率最高
    可以通过Runtime.getRuntime().availableProcessors() 获取主机核心线程数
    2.IO 密集型 判断程序中消耗IO的线程数，然后大于这个数


14.深入理解CAS
    比较当前工作内存中的值和主内存中的值，如果工作内存的值是期望值，则执行操作，如果不是就自旋锁一直循环。自带原子性
    缺点：1.自旋锁循环会耗时
         2.一次只能保证一个共享变量的原子性
    atomicInteger.getAndIncrement();
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
15.ABA问题
    有一个变量x 初始值为1
    线程A操作：如果预期的值是1的话就执行+1操作
    线程B操作：如果预期的值是1的话就执行+1操作，再执行-1操作。
    乐观锁解决ABA问题是通过引入版本号的确定变量在自己引用之前没有人动过