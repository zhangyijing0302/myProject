-- innodb存储数据是一页一页存的，读取的时候也是一页一页读的 默认一页的大小是16KB
show global status like 'Innodb_page_size';

叶子节点中有
User records 用户数据区域
Page Directory 页目录
页头


create table t1 (
    a int primary,
    b int,
    c int,
    d int,
    e varchar(10)
) engine = innodb;

show index from t1;

mysql认为B+树底层是一种优化后的B树，所以主键索引的index_type 还是BTREE

-- 在没有order by的情况下查询结果会自动根据主键索引排序
select * from t1;
-- mysql执行a = 7的sql语句时，是通过一页一次磁盘IO来读取数据的，读取到这一页后在内存中从这一页中找到a = 7的数据
select * from t1 where a = 7;
一页相当于一个对象
class Page {
    // 一个list大概就是16KB
    List<UserRecords> list;
}


在每一页的用户数据区域，各条数据时通过主键索引排序后通过指针的方式升序排列的
当数据库中没有a = 3的数据而执行a = 3的sql时, 会比较 a = 1, a = 2, a = 4,执行到这里发现a = 3 不存在就没有必要比较后边的数据了，可以直接返回了。
链表结构不适合查询，对于查询a = 30000的数据的时候，为了避免把小于30000的主键id都遍历一次，引入了页目录

目录结构
第一章 a ..... 1页
第二章 b ..... 7页
第三章 c ..... 19页

我们可以在叶子节点的页目录的目录项中存储一些东西，加快查询效率
把UserRecords区域的数据做一次分组，每一组的最小id存放在目录项中，适配a = 3的数据一定有一个合适的页目录分组，找到就是找到了，没找到就是没有，减少遍历次数。

但是一页只有16kb，会有存满一页的情况，需要新开一页
新页与旧页两边的数据是相连的，所以有一条旧页->新页的指针，这个指针存放在页头

页与页之间也是一个链表，当执行a = 30000的时候，需要从头到位遍历一页一页的数据，
所以增加了一个节点（16KB），节点中存放的是每一页的最小值
执行a = 30000的时候可以定位到应该在哪个叶子节点，只需要遍历一个叶子节点就可以了。



B树和B+树的区别
两个树都是有序的
B+树的特点：
1.一个节点中有多个元素
2.有序
3.叶子节点有双向指针
4.非叶子节点的元素都冗余了一份在叶子节点上
































