package com.myProject.leetCode.sort;

/**
 * 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列
 * 中的记录“基本有序”时，再对全体记录进行依次直接插入排序。
 */
public class 希尔排序 {

    /**
     * 无序数列：1、5、8、4、7、2、6、3 <tr/>
     * 分组增量=4（1、7）、（5、2）、（8、6）、（4、3）<tr/>
     * 插排：1、2、6、3、7、5、8、4 <tr/>
     * 分组增量=2（1、6、7、8）、（2、3、4、5）<tr/>
     * 插排：1、2、6、3、7、4、5、8 <tr/>
     * 分组增量=1 （1）、（2）、（6）、（3）、（7）、（4）、（5）、（8）<tr/>
     * 插排：1、2、3、4、5、6、7、8<tr/>
     *
     * @param a
     */
    private void shellSort(int[] a) {
        int dk = a.length / 2;
        while (dk >= 1) {
            ShellInsertSort(a, dk);
            dk = dk / 2;
        }
    }

    private void ShellInsertSort(int[] a, int dk) {
        //类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了
        for (int i = dk; i < a.length; i++) {
            if (a[i] < a[i - dk]) {
                int j;
                int x = a[i];//x 为待插入元素
                a[i] = a[i - dk];
                for (j = i - dk; j >= 0 && x < a[j]; j = j - dk) {
                    //通过循环，逐个后移一位找到要插入的位置。
                    a[j + dk] = a[j];
                }
                //插入
                a[j + dk] = x;
            }
        }
    }
    /**
     * 1.时间复杂度
     * 希尔排序算法利用分组粗调的方式减少了插入排序算法的工作量，使得算法的平均复杂度低于O(N^2)
     * 2.空间复杂度
     * 希尔排序算法排序过程中需要一个临时变量存储插入元素，所需要的额外空间为1，因此空间复杂度为O(1)
     * 3.稳定性
     * 希尔排序算法会进行分组排序，在分组排序的过程中有可能改变相同元素的前后位置，因此是一种不稳定的排序算法
     */
}
